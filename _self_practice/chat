# ====================== models.py ======================
from pydantic import BaseModel, Field
from bson import ObjectId
from typing import Optional


class PyObjectId(ObjectId):
    @classmethod
    def __get_validators__(cls):
        yield cls.validate

    @classmethod
    def validate(cls, v):
        if not ObjectId.is_valid(v):
            raise ValueError("Invalid ObjectId")
        return ObjectId(str(v))


class User(BaseModel):
    id: Optional[PyObjectId] = Field(alias="_id")
    name: str
    email: str

    class Config:
        json_encoders = {ObjectId: str}
        arbitrary_types_allowed = True


class Product(BaseModel):
    id: Optional[PyObjectId] = Field(alias="_id")
    name: str
    price: float

    class Config:
        json_encoders = {ObjectId: str}
        arbitrary_types_allowed = True


# ====================== base_repository.py ======================
from typing import TypeVar, Generic, Type, Optional, List
from models import BaseModel, ObjectId

T = TypeVar("T", bound=BaseModel)

class BaseRepository(Generic[T]):
    async def find_by_id(self, id: str) -> Optional[T]: ...
    async def find_all(self) -> List[T]: ...
    async def insert(self, data: T) -> str: ...
    async def update(self, id: str, data: dict) -> bool: ...
    async def delete_by_id(self, id: str) -> bool: ...


# ====================== repositories.py ======================
from bson import ObjectId
from base_repository import BaseRepository
from typing import Type, List, Optional
from models import User, Product

# Async Repository (Motor)
class AsyncRepository(BaseRepository):
    def __init__(self, collection, model_cls: Type):
        self.collection = collection
        self.model_cls = model_cls

    async def find_by_id(self, id: str) -> Optional:
        doc = await self.collection.find_one({"_id": ObjectId(id)})
        return self.model_cls(**doc) if doc else None

    async def find_all(self) -> List:
        return [self.model_cls(**doc async for doc in self.collection.find())]

    async def insert(self, data) -> str:
        result = await self.collection.insert_one(data.dict(by_alias=True))
        return str(result.inserted_id)

    async def update(self, id: str, data: dict) -> bool:
        result = await self.collection.update_one({"_id": ObjectId(id)}, {"$set": data})
        return result.modified_count > 0

    async def delete_by_id(self, id: str) -> bool:
        result = await self.collection.delete_one({"_id": ObjectId(id)})
        return result.deleted_count > 0


# Sync Repository (PyMongo)
class SyncRepository(BaseRepository):
    def __init__(self, collection, model_cls: Type):
        self.collection = collection
        self.model_cls = model_cls

    async def find_by_id(self, id: str) -> Optional:
        doc = self.collection.find_one({"_id": ObjectId(id)})
        return self.model_cls(**doc) if doc else None

    async def find_all(self) -> List:
        return [self.model_cls(**doc) for doc in self.collection.find()]

    async def insert(self, data) -> str:
        result = self.collection.insert_one(data.dict(by_alias=True))
        return str(result.inserted_id)

    async def update(self, id: str, data: dict) -> bool:
        result = self.collection.update_one({"_id": ObjectId(id)}, {"$set": data})
        return result.modified_count > 0

    async def delete_by_id(self, id: str) -> bool:
        result = self.collection.delete_one({"_id": ObjectId(id)})
        return result.deleted_count > 0


# ====================== services.py ======================
from models import User, Product
from typing import List, Optional
from base_repository import BaseRepository

class ProductService:
    def __init__(self, repo: BaseRepository[Product]):
        self.repo = repo

    async def get_products(self) -> List[Product]:
        return await self.repo.find_all()


class UserService:
    def __init__(self, repo: BaseRepository[User], product_service: ProductService):
        self.repo = repo
        self.product_service = product_service

    async def create_user(self, name: str, email: str) -> str:
        return await self.repo.insert(User(name=name, email=email))

    async def get_user(self, user_id: str) -> Optional[User]:
        return await self.repo.find_by_id(user_id)

    async def get_user_products(self, user_id: str) -> List[Product]:
        user = await self.repo.find_by_id(user_id)
        if user:
            return await self.product_service.get_products()
        return []


# ====================== mongo_client.py ======================
from pymongo import MongoClient
from motor.motor_asyncio import AsyncIOMotorClient

def get_client(use_motor=True):
    if use_motor:
        return AsyncIOMotorClient("mongodb://localhost:27017")
    else:
        return MongoClient("mongodb://localhost:27017")


# ====================== main.py ======================
import asyncio
from mongo_client import get_client
from repositories import AsyncRepository, SyncRepository
from models import User, Product
from services import UserService, ProductService

async def main(use_motor=True):
    client = get_client(use_motor)
    db = client["mydb"]

    RepoClass = AsyncRepository if use_motor else SyncRepository

    user_repo = RepoClass(db["users"], User)
    product_repo = RepoClass(db["products"], Product)

    product_service = ProductService(product_repo)
    user_service = UserService(user_repo, product_service)

    # Create user
    user_id = await user_service.create_user("Alice", "alice@example.com")
    print("Created user ID:", user_id)

    # List products via service-to-service call
    products = await user_service.get_user_products(user_id)
    print("User's products:", products)

if __name__ == "__main__":
    asyncio.run(main(use_motor=True))  # change to False to use PyMongo